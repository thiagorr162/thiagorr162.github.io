[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso de Programação Estatística",
    "section": "",
    "text": "Curso de Programação Estatística",
    "crumbs": [
      "Curso de Programação Estatística"
    ]
  },
  {
    "objectID": "index.html#objetivo-geral",
    "href": "index.html#objetivo-geral",
    "title": "Curso de Programação Estatística",
    "section": "Objetivo Geral",
    "text": "Objetivo Geral\nEste curso visa explorar o impacto das representações numéricas nos resultados de algoritmos de análise estatística. O foco será na programação, visualização e preparação de dados, além de discutir tópicos importantes como aleatoriedade, pseudoaleatoriedade, erros de truncamento e arredondamento, entre outros. O curso inclui ainda uma introdução à inferência por simulação estocástica, utilizando métodos como Monte Carlo e integrações numéricas. O material do curso foi amplamente baseado nas discussões apresentadas em Ross (2006).\nAutores: Andressa Cerqueira, Rafael Izbicki, Thiago Rodrigo Ramos\n\n\n\n\nRoss, Sheldon M. 2006. Simulation, Fourth Edition. USA: Academic Press, Inc.",
    "crumbs": [
      "Curso de Programação Estatística"
    ]
  },
  {
    "objectID": "1_intro.html",
    "href": "1_intro.html",
    "title": "1  Geração de Números Aleatórios e Aplicação em Problemas Estatísticos",
    "section": "",
    "text": "1.1 Objetivo da Aula\nNesta aula, vamos introduzir o conceito de números pseudoaleatórios e como eles podem ser usados para resolver problemas estatísticos por meio de simulação. Vamos abordar a importância da aleatoriedade em estatísticas e em algoritmos de Monte Carlo.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Problemas Estatísticos</span>"
    ]
  },
  {
    "objectID": "1_intro.html#conteúdo-teórico",
    "href": "1_intro.html#conteúdo-teórico",
    "title": "1  Geração de Números Aleatórios e Aplicação em Problemas Estatísticos",
    "section": "1.2 Conteúdo Teórico",
    "text": "1.2 Conteúdo Teórico\nA geração de números aleatórios é essencial em várias áreas da estatística e da ciência de dados. Esses números são utilizados em simulações estocásticas, amostragem e para resolver problemas que envolvem incerteza. Contudo, em computadores, os números “aleatórios” gerados são na verdade pseudoaleatórios, pois seguem uma sequência previsível, gerada por um algoritmo determinístico.\nOs números pseudoaleatórios são amplamente usados em algoritmos de Monte Carlo, que dependem da simulação repetida de processos aleatórios para estimar soluções para problemas matemáticos e estatísticos.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Problemas Estatísticos</span>"
    ]
  },
  {
    "objectID": "1_intro.html#exemplo-de-problema",
    "href": "1_intro.html#exemplo-de-problema",
    "title": "1  Geração de Números Aleatórios e Aplicação em Problemas Estatísticos",
    "section": "1.3 Exemplo de Problema",
    "text": "1.3 Exemplo de Problema\nVamos resolver o problema de estimar o valor de π (Pi) usando um método de Monte Carlo. A ideia é simular a área de um quarto de círculo inscrito em um quadrado. Gerando pontos aleatórios dentro do quadrado, podemos calcular a proporção desses pontos que também caem dentro do círculo e usar essa proporção para estimar o valor de Pi.\nComo fazer isso?\n\nRPython\n\n\n\n# Definindo o número de pontos a serem gerados\nn_pontos &lt;- 1000\n\n# Gerando pontos aleatórios (x, y) no intervalo [0, 1]\nx &lt;- runif(n_pontos, 0, 1)\ny &lt;- runif(n_pontos, 0, 1)\n\n# Calculando a distância de cada ponto à origem\ndistancia &lt;- sqrt(x^2 + y^2)\n\n# Contando quantos pontos estão dentro do quarto de círculo (distância &lt;= 1)\ndentro_circulo &lt;- distancia &lt;= 1\npi_estimado &lt;- 4 * sum(dentro_circulo) / n_pontos\n\n# Exibindo o valor estimado de Pi\ncat(\"Valor estimado de π:\", pi_estimado, \"\\n\")\n\nValor estimado de π: 3.148 \n\n# Visualizando a distribuição dos pontos\nlibrary(ggplot2)\n\ndados &lt;- data.frame(x = x, y = y, dentro_circulo = dentro_circulo)\n\nggplot(dados, aes(x = x, y = y, color = dentro_circulo)) +\n  geom_point(size = 1) +\n  scale_color_manual(values = c(\"red\", \"blue\")) +\n  ggtitle(paste0(\"Estimativa de π usando Monte Carlo\\nValor estimado: \", round(pi_estimado, 5))) +\n  theme_minimal() +\n  coord_equal() +\n  labs(x = \"x\", y = \"y\")\n\n\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo o número de pontos a serem gerados\nn_pontos = 1000\n\n# Gerando pontos aleatórios (x, y) no intervalo [0, 1]\nx = np.random.uniform(0, 1, n_pontos)\ny = np.random.uniform(0, 1, n_pontos)\n\n# Calculando a distância de cada ponto à origem\ndistancia = np.sqrt(x**2 + y**2)\n\n# Contando quantos pontos estão dentro do quarto de círculo (distância &lt;= 1)\ndentro_circulo = distancia &lt;= 1\npi_estimado = 4 * np.sum(dentro_circulo) / n_pontos\n\n# Exibindo o valor estimado de Pi\nprint(f\"Valor estimado de π: {pi_estimado}\")\n\nValor estimado de π: 3.192\n\n# Visualizando a distribuição dos pontos\nplt.figure(figsize=(6,6))\nplt.scatter(x, y, c=dentro_circulo, cmap='coolwarm', s=1)\nplt.title(f'Estimativa de π usando Monte Carlo\\nValor estimado: {pi_estimado}')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Problemas Estatísticos</span>"
    ]
  },
  {
    "objectID": "1_intro.html#exemplo-simulação-de-um-jogo-de-dados-com-dado-viciado",
    "href": "1_intro.html#exemplo-simulação-de-um-jogo-de-dados-com-dado-viciado",
    "title": "1  Geração de Números Aleatórios e Aplicação em Problemas Estatísticos",
    "section": "1.4 Exemplo: Simulação de um Jogo de Dados com Dado “Viciado”",
    "text": "1.4 Exemplo: Simulação de um Jogo de Dados com Dado “Viciado”\nImagine que estamos jogando um jogo em que o dado é “viciado” e não segue uma distribuição uniforme, ou seja, alguns números têm uma chance maior de serem sorteados. Por exemplo, o número 6 pode ter uma probabilidade maior, e os outros números, menores.\nIsso nos permite mostrar como alterar a probabilidade de ocorrência de eventos em uma distribuição discreta.\n\nRPython\n\n\n\n# Definindo as faces do dado e as probabilidades\nfaces &lt;- 1:6\nprobabilidades &lt;- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.25)  # Probabilidades associadas às faces do dado\n\n# Verificando que a soma das probabilidades é 1\ncat(\"Soma das probabilidades:\", sum(probabilidades), \"\\n\")\n\nSoma das probabilidades: 1 \n\n# Simulando 10000 lançamentos de um dado viciado\nn_lancamentos &lt;- 10000\nset.seed(123)  # Definindo seed para reprodutibilidade\nresultados &lt;- sample(faces, size = n_lancamentos, replace = TRUE, prob = probabilidades)\n\n# Contando as frequências de cada face\nfrequencias &lt;- table(resultados) / n_lancamentos\n\n# Exibindo os resultados da simulação\ncat(\"Frequências de cada face após\", n_lancamentos, \"lançamentos:\\n\")\n\nFrequências de cada face após 10000 lançamentos:\n\nfor (face in faces) {\n  cat(\"Face\", face, \":\", frequencias[as.character(face)], \"vezes\\n\")\n}\n\nFace 1 : 0.0473 vezes\nFace 2 : 0.0975 vezes\nFace 3 : 0.1504 vezes\nFace 4 : 0.1991 vezes\nFace 5 : 0.2582 vezes\nFace 6 : 0.2475 vezes\n\n# Visualizando os resultados em um gráfico de barras\nlibrary(ggplot2)\n\ndados &lt;- data.frame(faces = as.factor(faces), frequencias = as.numeric(frequencias))\n\nggplot(dados, aes(x = faces, y = frequencias)) +\n  geom_bar(stat = \"identity\", fill = \"lightcoral\", color = \"black\") +\n  ggtitle(paste0(\"Simulação de Lançamentos de um Dado Viciado\\n\", n_lancamentos, \" lançamentos\")) +\n  xlab(\"Face do Dado\") +\n  ylab(\"Frequência de Ocorrência\") +\n  theme_minimal() +\n  geom_text(aes(label = round(frequencias, 4)), vjust = -0.5) +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo as faces do dado e as probabilidades\nfaces = [1, 2, 3, 4, 5, 6]\nprobabilidades = [0.05, 0.1, 0.15, 0.2, 0.25, 0.25]  # Probabilidades associadas às faces do dado\n\n# Verificando que a soma das probabilidades é 1\nprint(f\"Soma das probabilidades: {sum(probabilidades)}\")\n\nSoma das probabilidades: 1.0\n\n# Simulando 10000 lançamentos de um dado viciado\nn_lancamentos = 10000\nresultados = np.random.choice(faces, size=n_lancamentos, p=probabilidades)\n\n# Contando as frequências de cada face\nfrequencias = [np.sum(resultados == face) / n_lancamentos for face in faces]\n\n# Exibindo os resultados da simulação\nprint(f\"Frequências de cada face após {n_lancamentos} lançamentos:\")\n\nFrequências de cada face após 10000 lançamentos:\n\nfor face, freq in zip(faces, frequencias):\n    print(f\"Face {face}: {freq} vezes\")\n\nFace 1: 0.0528 vezes\nFace 2: 0.0993 vezes\nFace 3: 0.1467 vezes\nFace 4: 0.2041 vezes\nFace 5: 0.2533 vezes\nFace 6: 0.2438 vezes\n\n# Visualizando os resultados em um gráfico de barras\nplt.figure(figsize=(8,6))\nplt.bar(faces, frequencias, color='lightcoral', edgecolor='black')\nplt.title(f'Simulação de Lançamentos de um Dado Viciado\\n{n_lancamentos} lançamentos')\nplt.xlabel('Face do Dado')\nplt.ylabel('Frequência de Ocorrência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Problemas Estatísticos</span>"
    ]
  },
  {
    "objectID": "1_intro.html#pergunta-precisamos-da-função-np.random.choiceset.seed",
    "href": "1_intro.html#pergunta-precisamos-da-função-np.random.choiceset.seed",
    "title": "1  Geração de Números Aleatórios e Aplicação em Problemas Estatísticos",
    "section": "1.5 Pergunta: precisamos da função np.random.choice/set.seed?",
    "text": "1.5 Pergunta: precisamos da função np.random.choice/set.seed?\n\nRPython\n\n\n\n# Definindo as faces do dado e as probabilidades associadas (não uniformes)\nfaces &lt;- 1:6\nprobabilidades &lt;- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.25)  # Probabilidades associadas às faces do dado\n\n# Função para gerar uma amostra baseada em intervalos de probabilidades\ngerar_amostra_por_intervalos &lt;- function(probabilidades, faces) {\n  u &lt;- runif(1)  # Gerando um número aleatório uniforme\n  limite_inferior &lt;- 0  # Limite inferior do intervalo\n  \n  # Percorrendo as probabilidades e verificando em qual intervalo o número cai\n  for (i in seq_along(probabilidades)) {\n    limite_superior &lt;- limite_inferior + probabilidades[i]  # Definindo o limite superior do intervalo\n    if (limite_inferior &lt;= u && u &lt; limite_superior) {\n      return(faces[i])  # Retorna a face correspondente ao intervalo\n    }\n    limite_inferior &lt;- limite_superior  # Atualiza o limite inferior para o próximo intervalo\n  }\n}\n\n# Simulando lançamentos do dado viciado utilizando a verificação dos intervalos\nn_lancamentos &lt;- 10000\nset.seed(123)  # Definindo seed para reprodutibilidade\nresultados &lt;- replicate(n_lancamentos, gerar_amostra_por_intervalos(probabilidades, faces))\n\n# Contando as frequências de cada face\nfrequencias &lt;- sapply(faces, function(face) sum(resultados == face) / n_lancamentos)\n\n# Exibindo os resultados da simulação\ncat(\"Frequências de cada face após\", n_lancamentos, \"lançamentos:\\n\")\n\nFrequências de cada face após 10000 lançamentos:\n\nfor (i in seq_along(faces)) {\n  cat(\"Face\", faces[i], \":\", frequencias[i], \"vezes\\n\")\n}\n\nFace 1 : 0.0521 vezes\nFace 2 : 0.0964 vezes\nFace 3 : 0.1527 vezes\nFace 4 : 0.2045 vezes\nFace 5 : 0.2508 vezes\nFace 6 : 0.2435 vezes\n\n# Visualizando os resultados em gráficos\n\nlibrary(ggplot2)\n\n# Gráfico das probabilidades ajustadas\ndados_probabilidades &lt;- data.frame(faces = as.factor(faces), probabilidades = probabilidades)\nggplot(dados_probabilidades, aes(x = faces, y = probabilidades)) +\n  geom_bar(stat = \"identity\", fill = \"skyblue\", color = \"black\") +\n  ggtitle(\"Probabilidades Ajustadas para o Dado Viciado\") +\n  xlab(\"Face do Dado\") +\n  ylab(\"Probabilidade\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n\n\n\n\n# Gráfico das frequências obtidas\ndados_frequencias &lt;- data.frame(faces = as.factor(faces), frequencias = frequencias)\nggplot(dados_frequencias, aes(x = faces, y = frequencias)) +\n  geom_bar(stat = \"identity\", fill = \"lightcoral\", color = \"black\") +\n  ggtitle(paste0(\"Simulação de Lançamentos de um Dado Viciado\\n\", n_lancamentos, \" lançamentos\")) +\n  xlab(\"Face do Dado\") +\n  ylab(\"Frequência de Ocorrência\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey80\"))\n\n\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo as faces do dado e as probabilidades associadas (não uniformes)\nfaces = [1, 2, 3, 4, 5, 6]\nprobabilidades = [0.05, 0.1, 0.15, 0.2, 0.25, 0.25]  # Probabilidades associadas às faces do dado\n\n# Gerando um número aleatório e verificando em qual intervalo ele cai\ndef gerar_amostra_por_intervalos(probabilidades, faces):\n    u = np.random.uniform(0, 1)  # Gerando um número aleatório uniforme\n    limite_inferior = 0  # Limite inferior do intervalo\n    \n    # Percorrendo as probabilidades e verificando em qual intervalo o número cai\n    for i, p in enumerate(probabilidades):\n        limite_superior = limite_inferior + p  # Definindo o limite superior do intervalo\n        if limite_inferior &lt;= u &lt; limite_superior:\n            return faces[i]  # Retorna a face correspondente ao intervalo\n        limite_inferior = limite_superior  # Atualiza o limite inferior para o próximo intervalo\n\n# Simulando lançamentos do dado viciado utilizando a verificação dos intervalos\nn_lancamentos = 10000\nresultados = [gerar_amostra_por_intervalos(probabilidades, faces) for _ in range(n_lancamentos)]\n\n# Contando as frequências de cada face\nfrequencias = [np.sum(np.array(resultados) == face) / n_lancamentos for face in faces]\n\n# Exibindo os resultados da simulação\nprint(f\"Frequências de cada face após {n_lancamentos} lançamentos:\")\n\nFrequências de cada face após 10000 lançamentos:\n\nfor face, freq in zip(faces, frequencias):\n    print(f\"Face {face}: {freq} vezes\")\n\nFace 1: 0.0511 vezes\nFace 2: 0.1016 vezes\nFace 3: 0.149 vezes\nFace 4: 0.201 vezes\nFace 5: 0.2445 vezes\nFace 6: 0.2528 vezes\n\n# Gráfico das probabilidades ajustadas\nplt.figure(figsize=(8,6))\nplt.bar(faces, probabilidades, color='skyblue', edgecolor='black')\nplt.title('Probabilidades Ajustadas para o Dado Viciado')\nplt.xlabel('Face do Dado')\nplt.ylabel('Probabilidade')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n# Gráfico das frequências obtidas\nplt.figure(figsize=(8,6))\nplt.bar(faces, frequencias, color='lightcoral', edgecolor='black')\nplt.title(f'Simulação de Lançamentos de um Dado Viciado\\n{n_lancamentos} lançamentos')\nplt.xlabel('Face do Dado')\nplt.ylabel('Frequência de Ocorrência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\nOu seja, se conseguimos simular uma distribuição uniforme, conseguimos simular uma distribuição discreta. Isso vale de forma mais geral?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Geração de Números Aleatórios e Aplicação em Problemas Estatísticos</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html",
    "href": "2_pseudorandom.html",
    "title": "2  Geração de Números Pseudoaleatórios",
    "section": "",
    "text": "2.1 O que é um número pseudoaleatório?\nUm número pseudoaleatório é gerado a partir de uma fórmula matemática que, a partir de uma semente (um valor inicial), gera uma sequência de números que tem as propriedades desejadas de uma sequência aleatória. Essa sequência parece aleatória, mas se a mesma semente for usada, a sequência será a mesma.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Geração de Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html#geração-de-números-pseudoaleatórios-com-o-gerador-linear-congruente-lcg",
    "href": "2_pseudorandom.html#geração-de-números-pseudoaleatórios-com-o-gerador-linear-congruente-lcg",
    "title": "2  Geração de Números Pseudoaleatórios",
    "section": "2.2 Geração de Números Pseudoaleatórios com o Gerador Linear Congruente (LCG)",
    "text": "2.2 Geração de Números Pseudoaleatórios com o Gerador Linear Congruente (LCG)\nLink para o wikipedia\nO Gerador Linear Congruente (LCG) é um dos métodos mais antigos e simples para gerar números pseudoaleatórios. Ele segue a fórmula:\n\\[\nX_{n+1} = (a \\cdot X_n + c) \\mod m\n\\]\nOnde: - \\(X_n\\) é o número atual (ou a semente inicial), - \\(a\\) é o multiplicador, - \\(c\\) é o incremento, - \\(m\\) é o módulo, ou seja, o intervalo dos números gerados.\nA sequência gerada pelo LCG depende diretamente dos parâmetros \\(a\\), \\(c\\), \\(m\\) e da semente inicial \\(X_0\\). Um conjunto mal escolhido de parâmetros pode resultar em uma sequência com um período curto, o que compromete a aleatoriedade da sequência.\n\n2.2.1 O que é a Função Módulo?\nA função módulo (também conhecida como operação de resto) retorna o resto da divisão de um número por outro. Em termos matemáticos, para dois números inteiros \\(a\\) e \\(b\\), a operação módulo é representada como:\n\\[\nr = a \\mod b\n\\]\nOnde: - \\(a\\) é o dividendo, - \\(b\\) é o divisor, - \\(r\\) é o resto da divisão de \\(a\\) por \\(b\\).\nPor exemplo, se temos \\(a = 17\\) e \\(b = 5\\), a divisão de 17 por 5 dá 3 com um resto de 2, então:\n\\[\n17 \\mod 5 = 2\n\\]\nNo contexto do Gerador Linear Congruente (LCG), a função módulo é usada para garantir que os números gerados fiquem dentro de um intervalo específico, geralmente entre 0 e \\(m-1\\), onde \\(m\\) é o módulo definido no algoritmo.\n\nRPython\n\n\n\n# Exemplo de uso da função módulo em R\n\n# Definindo os valores\na &lt;- 17\nb &lt;- 3\n\n# Calculando o módulo de a por b\nresto &lt;- a %% b\n\n# Exibindo o resultado\ncat(\"O resultado de\", a, \"%%\", b, \"é:\", resto, \"\\n\")\n\nO resultado de 17 %% 3 é: 2 \n\n\n\n\n\n# Exemplo de uso da função módulo em Python\n\n# Definindo os valores\na = 17\nb = 3\n\n# Calculando o módulo de a por b\nresto = a % b\n\n# Exibindo o resultado\nprint(f\"O resultado de {a} % {b} é: {resto}\")\n\nO resultado de 17 % 3 é: 2",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Geração de Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html#por-que-o-gerador-linear-congruente-funciona",
    "href": "2_pseudorandom.html#por-que-o-gerador-linear-congruente-funciona",
    "title": "2  Geração de Números Pseudoaleatórios",
    "section": "2.3 Por que o Gerador Linear Congruente Funciona?",
    "text": "2.3 Por que o Gerador Linear Congruente Funciona?\nO Gerador Linear Congruente (LCG) é um dos métodos mais simples e eficientes para gerar números pseudoaleatórios. Sua eficácia se baseia em um bom equilíbrio entre a escolha dos parâmetros (multiplicador \\(a\\), incremento \\(c\\), módulo \\(m\\) e semente inicial \\(X_0\\)) e as propriedades matemáticas que garantem uma sequência suficientemente “aleatória”. Para que o LCG funcione bem, os parâmetros precisam ser cuidadosamente selecionados para garantir que a sequência gerada tenha um período longo, seja bem distribuída e evite padrões repetitivos.\n\n2.3.1 A Fórmula do LCG\nA fórmula básica do LCG é:\n\\[\nX_{n+1} = (a \\cdot X_n + c) \\mod m\n\\]\nOnde: - \\(X_n\\) é o número gerado na \\(n\\)-ésima iteração, - \\(a\\) é o multiplicador, - \\(c\\) é o incremento, - \\(m\\) é o módulo, - \\(X_0\\) é a semente inicial.\nO número gerado em cada iteração é o resto da divisão de \\((a \\cdot X_n + c)\\) por \\(m\\). Essa operação garante que os números fiquem dentro do intervalo \\([0, m-1]\\). A normalização posterior geralmente transforma esses números em valores no intervalo \\([0, 1)\\).\n\n\n2.3.2 O Papel de \\(m\\)\nO valor de \\(m\\), conhecido como módulo, define o intervalo no qual os números gerados estarão contidos. Em muitos casos, \\(m\\) é escolhido como uma potência de 2 (por exemplo, \\(m = 2^{32}\\) ou \\(m = 2^{64}\\)) porque cálculos modulares com potências de 2 são mais rápidos em hardware.\nA escolha de \\(m\\) também influencia o período máximo da sequência. Se todos os parâmetros forem escolhidos corretamente, o LCG pode gerar uma sequência com o período máximo, que é \\(m\\). Isso significa que a sequência não repetirá nenhum número até que \\(m\\) números tenham sido gerados.\n\n\n2.3.3 O Papel de \\(a\\), \\(c\\) e a Condição de Coprimos\nPara garantir que o gerador tenha o período máximo (ou seja, \\(m\\) números diferentes antes de repetir a sequência), a escolha dos parâmetros \\(a\\) (multiplicador), \\(c\\) (incremento) e \\(m\\) (módulo) deve satisfazer as seguintes condições baseadas em teorias de números:\n\nO incremento \\(c\\) deve ser coprimo com \\(m\\):\n\nDois números são coprimos se o maior divisor comum deles for 1, ou seja, \\(\\text{gcd}(c, m) = 1\\). Isso garante que, ao somar \\(c\\), todos os possíveis valores de \\(X_n\\) possam ser atingidos antes de repetir a sequência.\nSe \\(c\\) não for coprimo com \\(m\\), a sequência gerada pode pular certos valores, resultando em um período mais curto do que o esperado.\n\nO valor de \\(a - 1\\) deve ser divisível por todos os fatores primos de \\(m\\):\n\nSe \\(m\\) é uma potência de 2 (por exemplo, \\(m = 2^k\\)), a escolha de \\(a\\) deve ser tal que \\((a - 1)\\) seja divisível por 2 para garantir que o período seja maximizado.\n\nSe \\(m\\) for divisível por 4, então \\((a - 1)\\) também deve ser divisível por 4:\n\nIsso é necessário para garantir que todos os resíduos modulares possíveis possam ser gerados, especialmente quando \\(m\\) é uma potência de 2.\n\n\n\n\n2.3.4 Exemplo de uma Escolha Correta de Parâmetros\nUm exemplo clássico de um bom conjunto de parâmetros é:\n\n\\(m = 2^{32}\\) (módulo com 32 bits),\n\\(a = 1664525\\) (multiplicador),\n\\(c = 1013904223\\) (incremento),\n\\(X_0 = 42\\) (semente inicial, que pode ser qualquer valor).\n\nEsses parâmetros foram escolhidos para garantir que o LCG tenha um longo período e uma boa distribuição dos números gerados. O módulo \\(m = 2^{32}\\) é uma potência de 2, o que torna as operações modulares mais rápidas, e os valores de \\(a\\) e \\(c\\) satisfazem as condições matemáticas para maximizar o período.\n\nRPython\n\n\n\n# Importando o pacote necessário\nlibrary(gmp)\n\n\nAttaching package: 'gmp'\n\n\nThe following objects are masked from 'package:base':\n\n    %*%, apply, crossprod, matrix, tcrossprod\n\n# Parâmetros do exemplo\nm &lt;- 2^32\na &lt;- 1664525\nc &lt;- 1013904223\n\n# Verificando as condições\n# 1. O incremento c deve ser coprimo com m\ncoprimo_c_m &lt;- gcd(c, m) == 1\n\n# 2. a - 1 deve ser divisível por todos os fatores primos de m\na_menos_1 &lt;- a - 1\n\nprint(a_menos_1)\n\n[1] 1664524\n\n# Verificando se a - 1 é divisível por 2 (único fator primo de m = 2^32)\ndivisivel_por_2 &lt;- (a_menos_1 %% 2 == 0)\n\n# 3. Se m for divisível por 4, a - 1 também deve ser divisível por 4\ndivisivel_por_4 &lt;- (a_menos_1 %% 4 == 0)\n\nlist(coprimo_c_m, divisivel_por_2, divisivel_por_4)\n\n[[1]]\n[1] TRUE\n\n[[2]]\n[1] TRUE\n\n[[3]]\n[1] TRUE\n\n\n\n\n\nimport math\n\n# Parâmetros do exemplo\nm = 2**32\na = 1664525\nc = 1013904223\n\n# Verificando as condições\n# 1. O incremento c deve ser coprimo com m\ncoprimo_c_m = math.gcd(c, m) == 1\n\n# 2. a - 1 deve ser divisível por todos os fatores primos de m\na_menos_1 = a - 1\n\nprint(a_menos_1)\n\n1664524\n\n# Verificando se a - 1 é divisível por 2 (único fator primo de m = 2^32)\ndivisivel_por_2 = (a_menos_1 % 2 == 0)\n\n# 3. Se m for divisível por 4, a - 1 também deve ser divisível por 4\ndivisivel_por_4 = (a_menos_1 % 4 == 0)\n\ncoprimo_c_m, divisivel_por_2, divisivel_por_4\n\n(True, True, True)\n\n\n\n\n\n\n\n2.3.5 Por que o LCG Funciona Bem?\nO LCG funciona porque: - As operações modulares garantem que os números gerados estejam dentro de um intervalo fixo e possam cobrir todo o espaço de possíveis valores de maneira ordenada. - A escolha adequada dos parâmetros garante que a sequência tenha um longo período (o maior possível dado \\(m\\)), evita padrões repetitivos e assegura que a sequência seja pseudoaleatória o suficiente para muitas aplicações, como simulações e métodos de Monte Carlo.\nNo entanto, o LCG pode não ser adequado para todas as aplicações, especialmente em criptografia, onde a previsibilidade é um problema. Para a maioria dos usos científicos e de simulação, ele ainda é uma escolha eficiente e simples.\n\n\n2.3.6 Efeito dos Parâmetros no Gerador Linear Congruente (LCG)\nOs parâmetros no Gerador Linear Congruente (LCG) têm um impacto significativo sobre a qualidade e as propriedades da sequência de números pseudoaleatórios gerados. Os parâmetros principais são:\n\nMultiplicador \\(a\\):\n\nEsse parâmetro é essencial para garantir que a sequência de números gerados tenha um bom período (o número de valores distintos antes de a sequência começar a se repetir). Se o valor de \\(a\\) não for bem escolhido, o período da sequência pode ser curto e a qualidade dos números gerados diminui.\nBons valores de \\(a\\) são cruciais para evitar padrões repetitivos ou ciclos curtos.\n\nIncremento \\(c\\):\n\nO incremento \\(c\\) adiciona um valor fixo à sequência e é um dos fatores que pode garantir que todos os valores no intervalo \\([0, m)\\) sejam atingidos em algum momento, desde que os outros parâmetros também sejam bem escolhidos.\nQuando \\(c = 0\\), o gerador é chamado de multiplicativo. Nessa forma, o LCG pode ter um comportamento menos uniforme.\n\nMódulo \\(m\\):\n\nO módulo define o intervalo dos números gerados. Comumente, \\(m\\) é escolhido como uma potência de 2 (por exemplo, \\(m = 2^{32}\\)) para facilitar os cálculos modulares em hardware e software.\nO valor de \\(m\\) também determina o período máximo da sequência de números. Com um módulo de \\(m\\), o período máximo teórico que o LCG pode ter é \\(m\\), mas isso depende da escolha correta dos parâmetros \\(a\\) e \\(c\\).\n\nSemente \\(X_0\\):\n\nA semente é o valor inicial de \\(X_0\\) usado pelo LCG para iniciar a sequência. Mudar a semente resultará em uma sequência diferente, mas com o mesmo período e comportamento determinado pelos outros parâmetros.\nA semente garante que o algoritmo possa ser reproduzido. Se dois programas utilizarem a mesma semente com os mesmos parâmetros, ambos produzirão a mesma sequência de números.\n\n\n\n\n2.3.7 Impacto dos Parâmetros:\n\nPeríodo da Sequência:\n\nO período é a quantidade de números gerados antes que a sequência comece a se repetir. Para obter o período máximo, os parâmetros \\(a\\), \\(c\\), \\(m\\) e a semente \\(X_0\\) precisam ser cuidadosamente escolhidos.\nSe os parâmetros não forem bons, o gerador pode produzir uma sequência com um ciclo muito curto ou, pior, um conjunto pequeno de valores.\n\nDistribuição dos Números:\n\nEmbora o LCG gere números no intervalo \\([0, 1)\\), o quão bem distribuídos esses números estão nesse intervalo depende dos parâmetros.\nParâmetros mal escolhidos podem causar uma distribuição não uniforme, onde certos intervalos terão mais números gerados que outros, levando a um comportamento indesejável.\n\nPadrões Repetitivos:\n\nSe os parâmetros forem mal escolhidos, podem surgir padrões repetitivos que comprometem a aleatoriedade dos números. Esses padrões tornam o LCG inadequado para algumas aplicações, como criptografia ou simulações que exigem alta qualidade de aleatoriedade.\n\n\nPor essas razões, a escolha dos parâmetros \\(a\\), \\(c\\), \\(m\\) e da semente \\(X_0\\) é crítica para garantir que o LCG produza números pseudoaleatórios de alta qualidade e com um período longo.\n\nRPython\n\n\n\n# Carregando o pacote ggplot2\nlibrary(ggplot2)\n\n# Classe para o Gerador Congruente Linear\nLinearCongruentialGenerator &lt;- setRefClass(\n  \"LinearCongruentialGenerator\",\n  fields = list(a = \"numeric\", c = \"numeric\", m = \"numeric\", semente = \"numeric\"),\n  methods = list(\n    initialize = function(semente, a = 1103515245, c = 12345, m = 2^32) {\n      .self$a &lt;- a\n      .self$c &lt;- c\n      .self$m &lt;- m\n      .self$semente &lt;- semente\n    },\n    gerar = function() {\n      # Atualizando a semente\n      .self$semente &lt;- (.self$a * .self$semente + .self$c) %% .self$m\n      return(.self$semente / .self$m)  # Normalizando para [0, 1)\n    }\n  )\n)\n\n# Inicializando o gerador com uma semente\nlcg &lt;- LinearCongruentialGenerator$new(semente = 5)\n\n# Gerando 1000 números pseudoaleatórios\nnumeros_gerados &lt;- sapply(1:100000, function(x) lcg$gerar())\n\n# Convertendo para um data.frame\ndados &lt;- data.frame(numeros_gerados = numeros_gerados)\n\n# Plotando o histograma dos números gerados\nggplot(dados, aes(x = numeros_gerados)) +\n  geom_histogram(bins = 20, fill = 'skyblue', color = 'black') +\n  ggtitle('Histograma dos Números Pseudoaleatórios Gerados pelo LCG') +\n  xlab('Valor') +\n  ylab('Frequência') +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey\"))\n\n\n\n\n\n\n\n\n\n\n\nimport matplotlib.pyplot as plt\n\nclass LinearCongruentialGenerator:\n    def __init__(self, semente, a=1103515245, c=12345, m=2**32):\n        self.a = a\n        self.c = c\n        self.m = m\n        self.semente = semente\n\n    def gerar(self):\n        # Atualizando a semente\n        self.semente = (self.a * self.semente + self.c) % self.m\n        return self.semente / self.m  # Normalizando para [0, 1)\n\n# Inicializando o gerador com uma semente\nlcg = LinearCongruentialGenerator(semente=5)\n\n# Gerando 1000 números pseudoaleatórios\nnumeros_gerados = [lcg.gerar() for _ in range(100000)]\n\n# Plotando o histograma dos números gerados\nplt.figure(figsize=(10, 6))\nplt.hist(numeros_gerados, bins=20, color='skyblue', edgecolor='black')\nplt.title('Histograma dos Números Pseudoaleatórios Gerados pelo LCG')\nplt.xlabel('Valor')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Geração de Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "2_pseudorandom.html#gerando-números-uniformes-com-uma-moeda",
    "href": "2_pseudorandom.html#gerando-números-uniformes-com-uma-moeda",
    "title": "2  Geração de Números Pseudoaleatórios",
    "section": "2.4 Gerando números uniformes com uma moeda",
    "text": "2.4 Gerando números uniformes com uma moeda\n\nRPython\n\n\n\n# Carregando pacotes necessários\nlibrary(ggplot2)\n\n# Função para simular o lançamento de uma moeda justa\nlancar_moeda &lt;- function() {\n  # Lançar moeda justa: 0 para coroa (K) e 1 para cara (C)\n  sample(c(0, 1), 1)\n}\n\n# Função para gerar um número uniformemente distribuído usando uma moeda\ngerar_numero_uniforme &lt;- function(n_bits = 32) {\n  numero &lt;- 0\n  for (i in 1:n_bits) {\n    bit &lt;- lancar_moeda()\n    # Atualizando o número, multiplicando pela base 2\n    numero &lt;- numero + bit * (2^-(i))\n  }\n  return(numero)\n}\n\n# Gerando 10000 números uniformemente distribuídos\nnumeros_uniformes &lt;- sapply(1:10000, function(x) gerar_numero_uniforme())\n \n# Convertendo para um data.frame\ndados &lt;- data.frame(numeros_uniformes = numeros_uniformes)\n\n# Plotando o histograma dos números gerados\nggplot(dados, aes(x = numeros_uniformes)) +\n  geom_histogram(bins = 20, fill = 'skyblue', color = 'black') +\n  ggtitle('Histograma de Números Uniformes Gerados Usando uma Moeda Justa') +\n  xlab('Valor') +\n  ylab('Frequência') +\n  theme_minimal() +\n  theme(panel.grid.major = element_line(color = \"grey\"))\n\n\n\n\n\n\n\n\n\n\n\nimport random\nimport matplotlib.pyplot as plt\n\n# Função para simular o lançamento de uma moeda justa\ndef lancar_moeda():\n    # Lançar moeda justa: 0 para coroa (K) e 1 para cara (C)\n    return random.choice([0, 1])\n\n# Função para gerar um número uniformemente distribuído usando uma moeda\ndef gerar_numero_uniforme(n_bits=32):\n    numero = 0\n    for i in range(n_bits):\n        bit = lancar_moeda()\n        # Atualizando o número, multiplicando pela base 2\n        numero += bit * (2 ** -(i + 1))  # Cada bit tem um peso de 2^-(posição)\n    return numero\n\n# Gerando 1000 números uniformemente distribuídos\nnumeros_uniformes = [gerar_numero_uniforme() for _ in range(10000)]\n\n# Plotando o histograma dos números gerados\nplt.figure(figsize=(10, 6))\nplt.hist(numeros_uniformes, bins=20, color='skyblue', edgecolor='black')\nplt.title('Histograma de Números Uniformes Gerados Usando uma Moeda Justa')\nplt.xlabel('Valor')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Geração de Números Pseudoaleatórios</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html",
    "href": "3_discrete_inversion.html",
    "title": "3  Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão",
    "section": "",
    "text": "3.1 Geração de Variáveis Aleatórias Discretas Genéricas\nDado um conjunto de probabilidades \\(p(x_i)\\), onde \\(x_i\\) são os valores possíveis da variável aleatória discreta, e \\(p(x_i)\\) são suas respectivas probabilidades, a CDF \\(F(x)\\) é calculada como:\n\\[\nF(x_i) = \\sum_{j=1}^{i} p(x_j)\n\\]\nO algoritmo para gerar uma variável aleatória discreta genérica é:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-discretas-genéricas",
    "href": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-discretas-genéricas",
    "title": "3  Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão",
    "section": "",
    "text": "Gerar um número aleatório \\(u \\in [0, 1)\\).\nEncontrar o menor valor \\(x_i\\) tal que \\(F(x_i) \\geq u\\).\nRetornar \\(x_i\\).\n\n\nRPython\n\n\n\n# Exemplo de valores e probabilidades de uma variável aleatória discreta\nvalores &lt;- c(0, 1, 2, 3, 4, 5, 6)\nprobabilidades &lt;- c(0, 0.1, 0.2, 0.3, 0.25, 0.15, 0) \n\n# Calculando a CDF\ncdf &lt;- cumsum(probabilidades)\n\n# Gerando um número aleatório uniforme\nu &lt;- runif(1)\n\n# Encontrando o valor correspondente na CDF\nvalor_gerado &lt;- NA\nfor (i in seq_along(valores)) {\n  if (u &lt; cdf[i]) {\n    valor_gerado &lt;- valores[i]\n    break\n  }\n}\n\n# Ajustando o gráfico para corrigir a visualização da CDF e garantir que os valores estejam corretamente posicionados\nlibrary(ggplot2)\n\n# Criando um dataframe para os valores e CDF\ndf &lt;- data.frame(valores = valores, cdf = cdf)\n\n# Gráfico da CDF com número aleatório e valor gerado\nggplot(df, aes(x = valores, y = cdf)) +\n  geom_step(direction = \"hv\", color = \"blue\", size = 1.5) +\n  geom_hline(yintercept = u, color = \"red\", linetype = \"dashed\") +\n  geom_vline(xintercept = valor_gerado, color = \"green\", linetype = \"dashed\") +\n  labs(title = \"Técnica da Inversão para Geração de Variável Aleatória Discreta\",\n       x = \"Valores da Variável Aleatória\", \n       y = \"CDF\") +\n  annotate(\"text\", x = max(valores), y = u, label = sprintf(\"u = %.2f\", u), hjust = -0.1, vjust = -1) +\n  annotate(\"text\", x = valor_gerado, y = max(cdf), label = paste(\"Valor gerado =\", valor_gerado), hjust = -0.1, vjust = -0.5) +\n  theme_minimal() +\n  theme(panel.grid = element_blank())\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\n\n\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n \n# Exemplo de valores e probabilidades de uma variável aleatória discreta\nvalores = [0, 1, 2, 3, 4, 5, 6]\nprobabilidades = [0, 0.1, 0.2, 0.3, 0.25, 0.15, 0]\n\n# Calculando a CDF\ncdf = np.cumsum(probabilidades)\n\n# Gerando um número aleatório uniforme\nu = np.random.uniform(0, 1)\n\n# Encontre o valor correspondente na CDF\nvalor_gerado = None\nfor i, valor in enumerate(valores):\n    if u &lt; cdf[i]:\n        valor_gerado = valor\n        break\n# Ajustando o gráfico para corrigir a visualização da CDF e garantir que os valores estejam corretamente posicionados\nplt.figure(figsize=(10, 6))\n\n# Ajustando o eixo x para que a CDF comece e termine corretamente\nplt.step(valores, cdf, label='CDF', color='blue', linewidth=2, where='post')\nplt.axhline(y=u, color='red', linestyle='--', label=f'Número aleatório u = {u:.2f}')\nplt.axvline(x=valor_gerado, color='green', linestyle='--', label=f'Valor gerado = {valor_gerado}')\nplt.title('Técnica da Inversão para Geração de Variável Aleatória Discreta')\nplt.xlabel('Valores da Variável Aleatória')\nplt.ylabel('CDF')\nplt.legend()\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#inversa-da-cdf",
    "href": "3_discrete_inversion.html#inversa-da-cdf",
    "title": "3  Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão",
    "section": "3.2 Inversa da CDF",
    "text": "3.2 Inversa da CDF\nA inversa da CDF (função de distribuição acumulada), também conhecida como a função quantil ou função percentil, é uma função utilizada para gerar variáveis aleatórias a partir de uma distribuição específica.\nDefinição: Seja \\(F(x)\\) a função de distribuição acumulada (CDF) de uma variável aleatória \\(X\\). A inversa da CDF, denotada por \\(F^{-1}(p)\\), é definida como:\n\\[\nF^{-1}(p) = \\inf \\{ x \\in \\mathbb{R} : F(x) \\geq p \\}, \\quad \\text{para } p \\in [0, 1]\n\\]\nEm palavras: - A inversa da CDF \\(F^{-1}(p)\\) mapeia um número \\(p\\), que representa uma probabilidade acumulada, de volta ao valor \\(x\\) correspondente da variável aleatória \\(X\\), tal que a probabilidade acumulada até \\(x\\) é igual a \\(p\\). - Isso significa que, se \\(p = F(x)\\), então \\(F^{-1}(p) = x\\).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-com-distribuição-geométrica",
    "href": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-com-distribuição-geométrica",
    "title": "3  Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão",
    "section": "3.3 Geração de Variáveis Aleatórias com Distribuição Geométrica",
    "text": "3.3 Geração de Variáveis Aleatórias com Distribuição Geométrica\nA distribuição geométrica modela o número de tentativas até o primeiro sucesso em uma sequência de experimentos de Bernoulli. Se a probabilidade de sucesso em cada tentativa é \\(p\\), a PMF é dada por:\n\n3.3.1 Derivação da Inversa da CDF para a Distribuição Geométrica\nA fórmula da inversa da CDF para a distribuição geométrica foi obtida a partir da definição da função de distribuição acumulada (CDF) da distribuição geométrica e da aplicação da técnica da inversão.\n\n3.3.1.1 CDF da Distribuição Geométrica\nA função de distribuição acumulada (CDF) da distribuição geométrica com parâmetro \\(p\\) (a probabilidade de sucesso) para o número de falhas \\(k-1\\) antes do primeiro sucesso é dada por:\n\\[\nF(k) = 1 - (1 - p)^k\n\\]\nEssa equação expressa a probabilidade acumulada de obter o primeiro sucesso em até \\(k\\) tentativas.\n\n\n3.3.1.2 Inversa da CDF\nQueremos encontrar a inversa da CDF, ou seja, a fórmula que, dado um valor \\(u\\) entre 0 e 1, nos permita calcular o valor \\(k\\) tal que \\(F(k) = u\\).\nSabemos que:\n\\[\nu = F(k) = 1 - (1 - p)^k\n\\]\nNosso objetivo é resolver essa equação para \\(k\\). Vamos fazer isso passo a passo.\n\n\n3.3.1.3 Isolando o termo com \\(k\\)\nComeçamos isolando o termo \\((1 - p)^k\\):\n\\[\nu = 1 - (1 - p)^k\n\\]\nSubtraindo 1 de ambos os lados:\n\\[\nu - 1 = - (1 - p)^k\n\\]\nMultiplicando ambos os lados por \\(-1\\):\n\\[\n1 - u = (1 - p)^k\n\\]\n\n\n3.3.1.4 Aplicando o Logaritmo\nAgora aplicamos o logaritmo natural (log base \\(e\\)) em ambos os lados para resolver \\(k\\):\n\\[\n\\log(1 - u) = \\log((1 - p)^k)\n\\]\nUsando a propriedade dos logaritmos que permite trazer o expoente \\(k\\) para frente:\n\\[\n\\log(1 - u) = k \\cdot \\log(1 - p)\n\\]\n\n\n3.3.1.5 Isolando \\(k\\)\nAgora, isolamos \\(k\\):\n\\[\nk = \\frac{\\log(1 - u)}{\\log(1 - p)}\n\\]\nComo \\(k\\) precisa ser um número inteiro (já que a distribuição geométrica conta o número de tentativas), usamos a função de arredondamento “para cima” (\\(\\lceil \\cdot \\rceil\\)), conhecida como a função teto:\n\\[\nk = \\lceil \\frac{\\log(1 - u)}{\\log(1 - p)} \\rceil\n\\]\n\n\n\n3.3.2 Conclusão\nPortanto, a fórmula da inversa da CDF da distribuição geométrica é:\n\\[\nk = \\lceil \\frac{\\log(1 - u)}{\\log(1 - p)} \\rceil\n\\]\nEsta fórmula nos permite gerar variáveis aleatórias com distribuição geométrica a partir de um número aleatório uniforme \\(u \\in [0, 1)\\).\n\nRPython\n\n\n\n# Função para gerar a inversa da CDF para a distribuição geométrica\ninversa_cdf_geometrica &lt;- function(p, u) {\n  # Usando a fórmula inversa da CDF geométrica: F⁻¹(u) = ceil(log(1 - u) / log(1 - p))\n  k &lt;- ceiling(log(1 - u) / log(1 - p))\n  return(as.integer(k))\n}\n\n# Parâmetro p da distribuição geométrica\np &lt;- 0.5\n\n# Gerando 1000 números uniformemente distribuídos\nuniformes &lt;- runif(1000)\n\n# Gerando a variável aleatória geométrica correspondente para cada número uniforme\ngeometricas &lt;- sapply(uniformes, inversa_cdf_geometrica, p = p)\n\n# Plotando um histograma das variáveis geométricas geradas\nlibrary(ggplot2)\n\ndf &lt;- data.frame(geometricas = geometricas)\nggplot(df, aes(x = geometricas)) +\n  geom_histogram(bins = max(geometricas) + 1, color = \"black\", fill = \"skyblue\", boundary = 0, closed = \"left\") +\n  labs(title = \"Histograma de Variáveis Aleatórias Geométricas Usando a Inversa da CDF\",\n       x = \"Valor da Variável Aleatória Geométrica\", \n       y = \"Frequência\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n# Função para calcular a CDF da distribuição geométrica\ncdf_geometrica &lt;- function(k, p) {\n  return(1 - (1 - p)^k)\n}\n\n# Gerando valores de k para plotar a CDF\nk_values &lt;- 1:20\ncdf_values &lt;- sapply(k_values, cdf_geometrica, p = p)\n\n# Plotando a CDF da distribuição geométrica\ndf_cdf &lt;- data.frame(k_values = k_values, cdf_values = cdf_values)\nggplot(df_cdf, aes(x = k_values, y = cdf_values)) +\n  geom_step(direction = \"hv\", color = \"blue\", size = 1.5) +\n  labs(title = \"CDF da Distribuição Geométrica (p = 0.5)\",\n       x = \"k (Número de tentativas até o primeiro sucesso)\", \n       y = \"F(k)\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Função para gerar a inversa da CDF para a distribuição geométrica\ndef inversa_cdf_geometrica(p, u):\n    # Usando a fórmula inversa da CDF geométrica: F⁻¹(u) = ceil(log(1 - u) / log(1 - p))\n    k = np.ceil(np.log(1 - u) / np.log(1 - p))\n    return int(k)\n\n# Parâmetro p da distribuição geométrica\np = 0.5\n\n# Gerando 100 números uniformemente distribuídos\nuniformes = np.random.uniform(0, 1, 1000)\n\n# Gerando a variável aleatória geométrica correspondente para cada número uniforme\ngeometricas = [inversa_cdf_geometrica(p, u) for u in uniformes]\n\n# Plotando um histograma das variáveis geométricas geradas\nplt.figure(figsize=(10, 6))\nplt.hist(geometricas, bins=range(1, max(geometricas) + 1), color='skyblue', edgecolor='black', align='left')\nplt.title('Histograma de Variáveis Aleatórias Geométricas Usando a Inversa da CDF')\nplt.xlabel('Valor da Variável Aleatória Geométrica')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n# Calculando a CDF para a distribuição geométrica\ndef cdf_geometrica(k, p):\n    return 1 - (1 - p)**k\n\n# Gerando valores de k para plotar a CDF\nk_values = np.arange(1, 21)\ncdf_values = [cdf_geometrica(k, p) for k in k_values]\n\n# Plotando a CDF da distribuição geométrica\nplt.figure(figsize=(10, 6))\nplt.step(k_values, cdf_values, where='post', color='blue', label='CDF Geométrica', linewidth=2)\nplt.title('CDF da Distribuição Geométrica (p = 0.3)')\nplt.xlabel('k (Número de tentativas até o primeiro sucesso)')\nplt.ylabel('F(k)')\nplt.grid(True)\nplt.legend()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-com-distribuição-poisson",
    "href": "3_discrete_inversion.html#geração-de-variáveis-aleatórias-com-distribuição-poisson",
    "title": "3  Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão",
    "section": "3.4 Geração de Variáveis Aleatórias com Distribuição Poisson",
    "text": "3.4 Geração de Variáveis Aleatórias com Distribuição Poisson\nA distribuição de Poisson é usada para modelar o número de eventos que ocorrem em um intervalo de tempo ou espaço fixo, onde os eventos ocorrem com uma taxa constante \\(\\lambda\\) e de forma independente.\nA função de probabilidade de massa (PMF) da distribuição de Poisson é dada por:\n\\[\nP(X = k) = \\frac{\\lambda^k e^{-\\lambda}}{k!}, \\quad k = 0, 1, 2, \\ldots\n\\]\n\n3.4.1 Derivação da Inversa da CDF para a Distribuição Poisson Usando a Fórmula Recursiva\nA distribuição de Poisson tem uma fórmula recursiva que pode ser usada para calcular as probabilidades de forma mais eficiente. Em vez de recalcular a probabilidade \\(P(X = k)\\) a cada vez, podemos usar a seguinte relação recursiva:\n\\[\nP(X = k+1) = \\frac{\\lambda}{k+1} \\cdot P(X = k)\n\\]\nOnde \\(P(X = 0) = e^{-\\lambda}\\).\nEssa relação recursiva permite gerar variáveis aleatórias de Poisson sem precisar calcular fatoriais repetidamente, o que é mais eficiente para grandes valores de \\(\\lambda\\) ou grandes números de eventos \\(k\\).\n\n\n3.4.2 Técnica da Inversão Usando a Fórmula Recursiva\nPara gerar uma variável aleatória de Poisson usando a técnica da inversão e a fórmula recursiva, o processo é o seguinte:\n\nGerar um número aleatório uniforme \\(u \\in [0, 1)\\).\nCalcular a CDF acumulada para valores de \\(k\\), somando as probabilidades da PMF (usando a relação recursiva) até que a CDF acumulada seja maior ou igual a \\(u\\).\nO menor valor \\(k\\) tal que \\(F(k) \\geq u\\) será o número de eventos gerado pela distribuição Poisson.\n\n\n\n3.4.3 Explicação:\n\nFórmula Recursiva: A relação recursiva \\(P(X = k+1) = \\frac{\\lambda}{k+1} \\cdot P(X = k)\\) permite calcular as probabilidades de forma eficiente, atualizando a probabilidade de \\(P(X = k+1)\\) a partir de \\(P(X = k)\\).\nEficiência: Esta técnica evita o cálculo repetido de fatoriais, tornando-a mais eficiente, especialmente quando se está gerando variáveis para grandes valores de \\(\\lambda\\) ou quando se deseja calcular probabilidades para muitos eventos \\(k\\).\n\nEste método é amplamente utilizado por ser mais rápido e computacionalmente eficiente para a geração de variáveis aleatórias de Poisson.\n\nRPython\n\n\n\n# Função para gerar a inversa da CDF para a distribuição Poisson usando a técnica de inversão e a fórmula recursiva\ninversa_cdf_poisson_recursiva &lt;- function(lam, u) {\n  k &lt;- 0\n  p &lt;- exp(-lam)  # P(X=0)\n  F &lt;- p  # Iniciamos com a probabilidade P(X=0)\n  \n  # Continuamos somando até que F &gt;= u\n  while (u &gt; F) {\n    k &lt;- k + 1\n    p &lt;- p * lam / k  # Atualiza a probabilidade recursivamente para o próximo valor\n    F &lt;- F + p\n  }\n  \n  return(k)\n}\n\n# Parâmetro lambda da distribuição Poisson\nlam &lt;- 3\n\n# Gerando 1000 números uniformemente distribuídos\nuniformes &lt;- runif(1000)\n\n# Gerando a variável aleatória Poisson correspondente para cada número uniforme\npoisson_vars &lt;- sapply(uniformes, inversa_cdf_poisson_recursiva, lam = lam)\n\n# Plotando o histograma das variáveis Poisson geradas\nlibrary(ggplot2)\n\ndf &lt;- data.frame(poisson_vars = poisson_vars)\nggplot(df, aes(x = poisson_vars)) +\n  geom_histogram(bins = max(poisson_vars) + 1, color = \"black\", fill = \"skyblue\", boundary = 0, closed = \"left\") +\n  labs(title = \"Histograma de Variáveis Aleatórias Poisson Usando a Fórmula Recursiva (λ = 3)\",\n       x = \"Valor da Variável Aleatória Poisson\", \n       y = \"Frequência\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n# Função para calcular a CDF da distribuição Poisson\ncdf_poisson &lt;- function(k, lam) {\n  cdf &lt;- 0\n  p &lt;- exp(-lam)  # P(X=0)\n  for (i in 0:k) {\n    cdf &lt;- cdf + p  # Adiciona a probabilidade à CDF\n    if (i &lt; k) {\n      p &lt;- p * lam / (i + 1)  # Atualiza a probabilidade recursivamente\n    }\n  }\n  return(cdf)\n}\n\n# Gerando valores de k para a CDF\nk_values &lt;- 0:14\ncdf_values &lt;- sapply(k_values, cdf_poisson, lam = lam)\n\n# Plotando a CDF da distribuição Poisson\ndf_cdf &lt;- data.frame(k_values = k_values, cdf_values = cdf_values)\nggplot(df_cdf, aes(x = k_values, y = cdf_values)) +\n  geom_step(direction = \"hv\", color = \"blue\", size = 1.5) +\n  labs(title = \"CDF da Distribuição Poisson Usando a Fórmula Recursiva (λ = 3)\",\n       x = \"k (Número de eventos)\", \n       y = \"F(k)\") +\n  theme_minimal() +\n  theme(panel.grid.major = element_blank())\n\n\n\n\n\n\n\n\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport math\n\n# Função para gerar a inversa da CDF para a distribuição Poisson usando a técnica de inversão e a fórmula recursiva\ndef inversa_cdf_poisson_recursiva(lam, u):\n    k = 0\n    p = math.exp(-lam)  # P(X=0)\n    F = p  # Iniciamos com a probabilidade P(X=0)\n    \n    # Continuamos somando até que F &gt;= u\n    while u &gt; F:\n        k += 1\n        p = p * lam / k  # Atualiza a probabilidade recursivamente para o próximo valor\n        F += p\n    \n    return k\n\n# Parâmetro lambda da distribuição Poisson\nlam = 3\n\n# Gerando 1000 números uniformemente distribuídos\nuniformes = np.random.uniform(0, 1, 1000)\n\n# Gerando a variável aleatória Poisson correspondente para cada número uniforme\npoisson_vars = [inversa_cdf_poisson_recursiva(lam, u) for u in uniformes]\n\n# Plotando o histograma das variáveis Poisson geradas\nplt.figure(figsize=(10, 6))\nplt.hist(poisson_vars, bins=range(0, max(poisson_vars) + 1), color='skyblue', edgecolor='black', align='left')\nplt.title('Histograma de Variáveis Aleatórias Poisson Usando a Fórmula Recursiva (λ = 3)')\nplt.xlabel('Valor da Variável Aleatória Poisson')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n# Calculando a CDF da distribuição Poisson\ndef cdf_poisson(k, lam):\n    cdf = 0\n    p = math.exp(-lam)  # P(X=0)\n    for i in range(k+1):\n        cdf += p  # Adiciona a probabilidade à CDF\n        if i &lt; k:  # Atualiza a probabilidade recursivamente\n            p = p * lam / (i + 1)\n    return cdf\n\n# Gerando valores de k para a CDF\nk_values = np.arange(0, 15)\ncdf_values = [cdf_poisson(k, lam) for k in k_values]\n\n# Plotando a CDF da distribuição Poisson\nplt.figure(figsize=(10, 6))\nplt.step(k_values, cdf_values, where='post', color='blue', label='CDF Poisson', linewidth=2)\nplt.title('CDF da Distribuição Poisson Usando a Fórmula Recursiva (λ = 3)')\nplt.xlabel('k (Número de eventos)')\nplt.ylabel('F(k)')\nplt.grid(True)\nplt.legend()\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão</span>"
    ]
  },
  {
    "objectID": "3_discrete_inversion.html#exercícios",
    "href": "3_discrete_inversion.html#exercícios",
    "title": "3  Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão",
    "section": "3.5 Exercícios",
    "text": "3.5 Exercícios\nExercício 1. Seja \\(X\\) uma v.a. tal que \\(\\mathbb P(X=1)=0.3,\\mathbb P(X=3)=0.1\\) e \\(\\mathbb P(X=4)=0.6\\).\n\nEscreva um pseudo-algoritmo para gerar um valor de \\(X\\).\nImplemente uma função para gerar \\(n\\) valores de \\(X\\).\nCompare a distribuição das frequências obtidas na amostra simulada com as probabilidades reais.\n\nExercício 2. Considere \\(X\\) uma v.a. tal que\n\\[\n\\mathbb{P}(X=i) = \\alpha \\mathbb{P}(X_1=i) + (1-\\alpha) \\mathbb{P}(X_2=i), \\quad i=0,1,\\dots\n\\]\nonde \\(0 \\leq \\alpha \\leq 1\\) e \\(X_1, X_2\\) são v.a. discretas.\nA distribuição de \\(X\\) é chamada de distribuição de mistura. Podemos escrever\n\\[\nX = \\begin{cases}\nX_1, & \\text{com probabilidade } \\alpha \\\\\nX_2, & \\text{com probabilidade } 1-\\alpha\n\\end{cases}\n\\]\nPseudo-Algoritmo:\n\nSeja \\(U\\sim Unif(0,1)\\)\nSe \\(U \\leq \\alpha\\), gere um valor da distribuição de \\(X_1\\). Senão, gere um valor da distribuição de \\(X_2\\)\n\nCom base no pseudo-algorimo implemente um algoritmo para gerar uma amostra de tamanho \\(n\\) da distribuição mistura de uma Poisson e de uma Geométrica com base nas funções implementadas nos Exercícios (2) e (3).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Geração de Variáveis Aleatórias Discretas Usando a Técnica da Inversão</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html",
    "href": "4_continuous_inversion.html",
    "title": "4  Geração de Variáveis Aleatórias Contínuas Usando a Técnica da Inversão e Transformações",
    "section": "",
    "text": "4.1 Função Inversa\nSabemos que \\(F: \\mathbb{R} \\to [0,1]\\), e, portanto, podemos definir a função inversa \\(F^{-1}: [0,1] \\to \\mathbb{R}\\). A seguir, mostramos como isso funciona.\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Definindo a função de distribuição acumulada F(x)\ndef F(x):\n    return 1 / (1 + np.exp(-x))  # Função logística como exemplo de F(x)\n\n# Definindo a inversa da função de distribuição acumulada F_inv(u)\ndef F_inv(u):\n    return -np.log((1 / u) - 1)\n\n# Gerando valores de x e u para plotar\nx = np.linspace(-4, 10, 400)\nu = np.linspace(0.01, 0.99, 400)  # U entre 0 e 1 (evitando extremos para evitar erros na inversa)\n\n# Plotando a função de distribuição acumulada F(x) com truncamento do eixo y no zero\nplt.figure(figsize=(8, 6))\nplt.plot(x, F(x), color=\"black\")\n\n# Adicionando linhas pontilhadas para representar U e F_inv(U)\nu_value = 0.7  # Exemplo de valor de U\nx_value = F_inv(u_value)\n\nplt.hlines(u_value, min(x), x_value, linestyles='dotted', colors='red')\nplt.vlines(x_value, 0, u_value, linestyles='dotted', colors='red')\n\n# Etiquetas\nplt.text(x_value-0.4 , -0.05, r\"$F^{-1}(u)$\", fontsize=12, color='red')\nplt.text(-5.5, u_value - 0.02, r\"$u$\", fontsize=14, color='red')\n\n# Rótulos e estilo do gráfico\nplt.title(r'Representação da Função de Distribuição Acumulada e sua Inversa', fontsize=14)\nplt.xlabel(r'$x$', fontsize=12)\nplt.ylabel(r'$F(x)$', fontsize=12)\nplt.ylim(0, 1.2)\nplt.xlim(-4, 10)\nplt.grid(True)\n\n# Exibir o gráfico\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Geração de Variáveis Aleatórias Contínuas Usando a Técnica da Inversão e Transformações</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#método-da-inversão",
    "href": "4_continuous_inversion.html#método-da-inversão",
    "title": "4  Geração de Variáveis Aleatórias Contínuas Usando a Técnica da Inversão e Transformações",
    "section": "4.2 Método da Inversão",
    "text": "4.2 Método da Inversão\nPara gerar valores de uma variável aleatória contínua \\(X\\), usamos o método da inversão, que segue a seguinte proposição:\nProposição: Seja \\(U \\sim \\text{Unif}(0,1)\\). Para qualquer variável aleatória contínua com função de distribuição acumulada \\(F\\), a variável: \\[\nX = F^{-1}(U)\n\\] tem distribuição \\(F\\).\nProva: \\[\n\\mathbb{P}(X \\leq x) = \\mathbb{P}(F^{-1}(U) \\leq x) = \\mathbb{P}(F(F^{-1}(U)) \\leq F(x)) = \\mathbb{P}(U \\leq F(x)) = F(x).\n\\]\nO método da inversão consiste em:\n\nGerar \\(U \\sim \\text{Unif}(0,1)\\).\nCalcular \\(X = F^{-1}(U)\\).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Geração de Variáveis Aleatórias Contínuas Usando a Técnica da Inversão e Transformações</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#exemplo-1",
    "href": "4_continuous_inversion.html#exemplo-1",
    "title": "4  Geração de Variáveis Aleatórias Contínuas Usando a Técnica da Inversão e Transformações",
    "section": "4.3 Exemplo 1",
    "text": "4.3 Exemplo 1\nSeja \\(X\\) uma v.a. com: \\[\nF(x) = x^n, \\quad \\text{para } 0 &lt; x &lt; 1.\n\\]\nA função inversa é: \\[\nu = F(x) = x^n \\implies x = u^{1/n}.\n\\]\nPortanto, o pseudo-algoritmo para gerar \\(X\\) é:\n\nGere \\(U \\sim \\text{Unif}(0,1)\\).\nCalcule \\(X = U^{1/n}\\).\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parâmetro n da distribuição F(x) = x^n\nn = 3\n\n# Gerando 1000 valores U de uma distribuição uniforme (0,1)\nU = np.random.uniform(0, 1, 1000)\n\n# Calculando X = U^(1/n)\nX = U**(1/n)\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(X, bins=30, color='skyblue', edgecolor='black', density=True)\nplt.title('Histograma de variáveis geradas pela inversão: F(x) = x^n, n = 3')\nplt.xlabel('Valor de X')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n4.3.1 Exemplo 2\nSeja \\(X \\sim \\text{Exp}(\\lambda)\\), com: \\[\nF(x) = 1 - e^{-\\lambda x}, \\quad \\text{para } x &gt; 0.\n\\]\nA função inversa é: \\[\nu = F(x) = 1 - e^{-\\lambda x} \\implies x = -\\frac{\\log(1 - u)}{\\lambda}.\n\\]\nO pseudo-algoritmo para gerar \\(X\\) é:\n\nGere \\(U \\sim \\text{Unif}(0,1)\\).\nCalcule \\(X = -\\frac{\\log(1 - U)}{\\lambda}\\).\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Parâmetro lambda da distribuição exponencial\nlambd = 2\n\n# Gerando 1000 valores U de uma distribuição uniforme (0,1)\nU = np.random.uniform(0, 1, 1000)\n\n# Calculando X usando a inversa da CDF da exponencial\nX = -np.log(1 - U) / lambd\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(X, bins=30, color='lightcoral', edgecolor='black', density=True)\nplt.title('Histograma de variáveis geradas pela inversão: Distribuição Exponencial')\nplt.xlabel('Valor de X')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Geração de Variáveis Aleatórias Contínuas Usando a Técnica da Inversão e Transformações</span>"
    ]
  },
  {
    "objectID": "4_continuous_inversion.html#simulação-de-transformações-de-variáveis-aleatórias",
    "href": "4_continuous_inversion.html#simulação-de-transformações-de-variáveis-aleatórias",
    "title": "4  Geração de Variáveis Aleatórias Contínuas Usando a Técnica da Inversão e Transformações",
    "section": "4.4 Simulação de transformações de variáveis aleatórias",
    "text": "4.4 Simulação de transformações de variáveis aleatórias\nAgora que já sabemos como simular uma variável aleatória \\(X\\), o próximo passo é gerar valores de uma transformação dessa variável, ou seja, \\(g(X)\\).\n\n\n4.4.1 Exemplo 1: Simulando \\(Y \\sim Unif(1, 2)\\)\nPara gerar valores de \\(Y \\sim Unif(1, 2)\\), usamos o fato de que \\(Y\\) é uma simples transformação de \\(U \\sim Unif(0, 1)\\). A relação é: \\[\nY = U + 1.\n\\]\nO pseudo-algoritmo é:\n\nGere \\(U \\sim Unif(0,1)\\).\nCalcule \\(Y = U + 1\\).\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Gerando 1000 valores U de uma distribuição uniforme (0,1)\nU = np.random.uniform(0, 1, 1000)\n\n# Calculando Y = U + 1 para ter Y ~ Unif(1, 2)\nY = U + 1\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(Y, bins=30, color='skyblue', edgecolor='black', density=True)\nplt.title('Histograma de variáveis geradas: Y ~ Unif(1, 2)')\nplt.xlabel('Valor de Y')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\n\n\n4.4.2 Exemplo 2: Simulando \\(Y \\sim Gamma(n, \\lambda)\\)\nPara gerar valores de \\(Y \\sim \\Gamma(n, \\lambda)\\), somamos \\(n\\) variáveis aleatórias \\(X_1, \\dots, X_n\\), onde cada \\(X_i \\sim Exp(\\lambda)\\). A relação é: \\[\nY = X_1 + X_2 + \\dots + X_n.\n\\]\nO pseudo-algoritmo é:\n\nGere \\(U_1, \\dots, U_n \\sim Unif(0,1)\\) independentemente.\nCalcule \\(X_i = -\\frac{\\log(1 - U_i)}{\\lambda}\\) para \\(i = 1, \\dots, n\\).\nCalcule \\(Y = X_1 + X_2 + \\dots + X_n\\).\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n\n# Definindo parâmetros\nn = 5  # número de somas\nlambd = 2  # parâmetro da distribuição exponencial\n\n# Gerando 1000 valores U para cada uma das n somas\nU = np.random.uniform(0, 1, (1000, n))\n\n# Calculando X_i = -log(1 - U_i) / lambda para cada U_i\nX = -np.log(1 - U) / lambd\n\n# Somando os valores de X para obter Y ~ Gamma(n, lambda)\nY = np.sum(X, axis=1)\n\n# Plotando um histograma dos valores gerados\nplt.figure(figsize=(10, 6))\nplt.hist(Y, bins=30, color='lightcoral', edgecolor='black', density=True)\nplt.title(f'Histograma de variáveis geradas: Y ~ Gamma({n}, {lambd})')\nplt.xlabel('Valor de Y')\nplt.ylabel('Frequência')\nplt.grid(True)\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Geração de Variáveis Aleatórias Contínuas Usando a Técnica da Inversão e Transformações</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Ross, Sheldon M. 2006. Simulation, Fourth Edition. USA:\nAcademic Press, Inc.",
    "crumbs": [
      "References"
    ]
  }
]